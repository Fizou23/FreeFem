//definition of the exact solution and source term
func uex = sin(pi*x)*sin(pi*y);
func fex = 2*(pi^2)*sin(pi*x)*sin(pi*y);

//Domains
//int n = 20;
//mesh Th = square(n,n);









///////////////////////////////////////////////////
/*
// multy border syntax version 3.30 avril 2014 ... 
real[int] xx=[0,1,1,0],
            yy=[0,0,1,1];
            
real hh = 0.125,HH=0.875,aa=0.25,AA=0.95;
real[int] xxi=[hh,HH,HH,hh],
          yyi=[aa,aa,AA,AA];
real pp = 0.125,PP=0.875,qq=0.951,QQ=0.999;
real[int] xxi2=[pp,PP,PP,pp],
          yyi2=[qq,qq,QQ,QQ];*/
/*
border bb(t=0,1;i) //varpi
  {
  // i is the the index variable of the multi border loop 
    int ii = (i+1)%4; real t1 = 1-t;
    x =  xx[i]*t1 + xx[ii]*t;
    y =  yy[i]*t1 + yy[ii]*t;
    label = 1; 
  }*/
  /*
  border bbi(t=0,1;i) //B
  {
  // i is the the index variable of the multi border loop 
    int ii = (i+1)%4; real t1 = 1-t;
    x =  xxi[i]*t1 + xxi[ii]*t;
    y =  yyi[i]*t1 + yyi[ii]*t;
    label = 0;
  }
  border bbi2(t=0,1;i) //le reste du domaine
  {
  // i is the the index variable of the multi border loop 
    int ii = (i+1)%4; real t1 = 1-t;
    x =  xxi2[i]*t1 + xxi2[ii]*t;
    y =  yyi2[i]*t1 + yyi2[ii]*t;
    label = 2; 
  }*/
//square,varpi and B defining borders

border S1(t=0,1) {x=t;y=0;}
border S2(t=0,1) {x=1;y=t;}
border S3(t=0,1) {x=1+(0.875-1)*t;y=1;}
border S4(t=0,1) {x=0.875+(0.125-0.875)*t;y=1;}
border S5(t=0,1) {x=0.125-0.125*t;y=1;}
border S6(t=0,1) {x=0;y=1-t;}

border S7(t=0,1) {x=0.875;y=0.95+(1-0.95)*t;}
border S8(t=0,1) {x=0.125+(0.875-0.125)*t;y=0.95;}
border S9(t=0,1) {x=0.125;y=1+(0.95-1)*t;}
border S10(t=0,1) {x=0.125;y=0.95+(0.25-0.95)*t;}
border S11(t=0,1) {x=0.125+(0.875-0.125)*t;y=0.25;}
border S12(t=0,1) {x=0.875;y=0.25+(0.95-0.25)*t;}

//mesh size
int NN=50,
    NNi=50;

mesh Th = buildmesh(S1(NN)+S2(NN)+S3(NN)+S4(NNi)+S5(NN)+S6(NN)+S7(NNi)+S8(NNi)+S9(NNi)+S10(NNi)+S11(NNi)+S12(NNi));
//plot(Th,wait=1);

/*
  border varpi1(t=0,1) {x=0.125;y=0.95+(1-0.95)*t;}
  border varpi2(t=0,1) {x=0.125+(0.875-0.125)*t;y=0.25;}
  border varpi3(t=0,1) {x=0.875;y=0.25+(0.95-0.25)*t;}

  border B01(t=0,1) {x=0.25;y=1+(1-0.95)*t;}
  border B02(t=0,1) {x=0.125+(0.875-0.125)*t;y=0.95;}
  border B03(t=0,1) {x=0.875;y=0.95+(1-0.95)*t;}*/


  /*
  int[int] NN(4),NNi(4),NNi2(4);
  NN = 20;
  NNi = 20;
  NNi2=20;
  mesh Th= buildmesh(bb(NN)+bbi(NNi)+bbi2(NNi2)) ;*/
  real h=0.01;
  Th = adaptmesh(Th, h, IsMetric=1); 
  plot(Th,wait=1);
  int regi = Th(0.5,0.5).region ;
  int regx = Th(0.01,0.01).region;
  int regh = Th(0.5,0.99).region;





/*
//varpi
border a1(t=1,0) {x = 0; y = t;}
border a2(t=1,0) {x = 0.125*t; y = 1;}
border a3(t=1,0) {x = 0.125; y = 1-0.75*t;}
border a4(t=1,0) {x = 0.125+(0.875-0.125)*t; y = 0.25;}
border a5(t=1,0) {x = 0.875; y = 0.25+0.75*t;}
border a6(t=1,0) {x = 0.875+0.125*t; y = 1;}
border a7(t=1,0) {x = 1; y = 1-t;}
border a8(t=1,0) {x = 1-t; y = 0;}
//plot(Th,wait=1);
mesh varpi = buildmesh(a8(50) + a7(50) + a6(10) + a5(50) + a4(50) + a3(50) + a2(10) + a1(50));
plot(varpi,wait=1);

// B
border b1(t=0,1) {x=0.125+(0.875-0.125)*t;y=0.25;}
border b2(t=0,1) {x=0.875; y= 0.25+(0.95-0.25)*t;}
border b3(t=0,1) {x=0.875+(0.125-0.875)*t;y=0.95;}
border b4(t=0,1) {x=0.125;y=0.95+(0.25-0.95)*t;}

mesh B = buildmesh(b1(50)+b2(50)+b3(50)+b4(50));*/
//plot(B,wait=1);


/* fespace Vhl(Th,P1);
Vhl xi,u,v,eta;
Vhl uexh=uex; */


/////////////////////

fespace Vh(Th,[P1,P1]);
fespace Wh(Th,P1);
Wh uexh = uex,fexh=fex;
Vh [u,xi],[v,eta];


macro dN(u) (dx(u)*N.x+dy(u)*N.y) //
macro grad(u) [dx(u),dy(u)] //
//real h=sqrt(2)/n;
real gamma = 5;




/*varf sh(u,v) = intalledges(Th)((nTonEdge-1)*h*jump(dN(u))*jump(dN(v)) );
varf a(u,v) = int2d(Th)(dx(u)*dx(v)+dy(u)*dy(v));
varf m(u,v) = int2d(varpi)(u*v);
varf L(u,v) = int2d(varpi) (uex*v);   // Linear form
varf lh(xi,eta) = int2d(Th)(fex*eta);*/
/*
varf varpb1([u,xi],[v,eta]) =   int2d(Th,regi)(dx(xi)*dx(v)+dy(xi)*dy(v)) + intalledges(Th)(gamma*(nTonEdge-1)*h*jump(dN(u))*jump(dN(v)) ) // a(v,xi) + sh(u,v);
+int2d(Th)(dx(u)*dx(eta)+dy(u)*dy(eta)) - intalledges(Th)(gamma*(nTonEdge-1)*h*jump(dN(xi))*jump(dN(eta)) ) - int2d(Th)(dx(xi)*dx(eta)+dy(xi)*dy(eta)) //a(u,eta) - sh(u,v) - a(xi,eta);
+ on(1,2,3,4,xi=0); //xi nulle sur le bord
cout<<"varf"<<endl; */
//a([u,xi],[v,eta]) + m([u,xi],[v,eta])  + sh([u,xi],[v,eta]) + a([u,xi],[v,eta]) - sh([u,xi],[v,eta]) - a([u,xi],[v,eta]) - L([u,xi],[v,eta]) - lh([u,xi],[v,eta]);
//varf rhspb1([unused,unused],[v,eta]) = int2d(varpi) (uexh*v) + int2d(Th)(fexh*eta);//L(unused,v) + lh(unused,eta);

/*
varf varpb1([u,xi],[v,eta]) = 
   int2d(Th,regx)( u*v ) + int2d(Th)( grad(xi)'*grad(v)  + grad(u)'*grad(eta)- grad(xi)'*grad(eta)) + intalledges(Th)(gamma*(nTonEdge-1)*h*jump(dN(u))*jump(dN(v)) )
      - intalledges(Th)(gamma*(nTonEdge-1)*h*jump(dN(xi))*jump(dN(eta))) + on(1,xi=0);*/

      /*- int2d(Th,regi)(uexh*v)*/
/*
varf rhspb1(unused,v) = int2d(Th,regx) (uexh*v);
varf rhspb2(unused,eta) = int2d(Th)(fexh*eta);*/






solve Pb([u,xi],[v,eta])= 
    int2d(Th,regx)( u*v ) + int2d(Th)( grad(xi)'*grad(v)  + grad(u)'*grad(eta)- grad(xi)'*grad(eta)) + intalledges(Th)(0.5*gamma*(nTonEdge-1)*h*jump(dN(u))*jump(dN(v)) )
      - intalledges(Th)(0.5*gamma*(nTonEdge-1)*h*jump(dN(xi))*jump(dN(eta))) - int2d(Th,regx)(uexh*v) - int2d(Th)(fexh*eta) + on(1,xi=0);






//varf aa1(u,v)= int2d(varpi)(u*v) + a(v,xi) + sh(u,v);

/////////////////////////////////////
//plot(Th,wait=1); //the split happens here
/////////////////////////////////////   


//matrix A = varpb1(Vh,Vh);


//plot(Th,wait=1);


/*for (int k=0;k<nbt;k++) {
    real Gx=0,Gy=0;
    for (int vert = 0;vert<3;vert++) {
        Gx+=Th[k][vert].x;
        Gy+=Th[k][vert].y;
    }
    Gx/=3.;
    Gy/=3.;
    //appel Ã  une fonction qui designe la geomterie
    if (invarpi()) {

    }
}*/

/*
////////////Adding the term in varpi
varf mass(u,v) = int2d(Th) (u*v);
matrix M = mass(Vh,Vh);
real[int] data = rhspb1(0,Wh);
//real[int] rhspb22 = 
int nbv = Th.nv; //nbre de noeuds
//real[int] zeros(Wh.ndof);
//zeros=0;

for (int v=0;v<nbv;v++) {
    real Kx=Th(v).x,Ky=Th(v).y;
    bool tst =  (((Ky>0.25) && ((Kx<=0.125)||(Kx>=0.875))) || (Ky<=0.25));
    if (!tst) {
        for (int counter=0;counter<nbv;counter++) {
            M(counter,v)=0;
            M(v,counter)=0;
        }
        data[v]=0;
    }
}
Wh data1;
data1[] = data;
plot(data1,wait=1,value=1,cmm="data");*/
//just another test
/*matrix K=[[1,2],[3,4]];
real[int] var = K[:,0];*/

//updating A
//A+=M;
/*
int nbperm = Wh.ndof;
int[int] perm1(nbperm);
int[int] perm2(nbperm);

int nbt= Th.nt; //nb of traingles
for (int k=0;k<nbt;k++) { //boucle sur les triangles
    for (int iloc=0;iloc<3;iloc++) {
        int iglob = Wh(k,iloc);
        perm1[iglob] = Vh(k,iloc);
        perm2[iglob] = Vh(k,iloc+3);
    }
}
//defining the right hand side
real[int] rhs1 = rhspb1(0,Wh);
real[int] sol1(Wh.ndof);

real[int] rhs2 = rhspb2(0,Wh);
real[int] sol2(Wh.ndof);
real[int] rhs(2*Wh.ndof);
for (int i=0;i<Wh.ndof;i++) {
    for (int j=0;j<Wh.ndof;j++) {
        A(perm1[i],perm1[j]) += M(i,j);
    }
    rhs[perm1[i]]=data[i];
    rhs[perm2[i]]=rhs2[i];
}*/


/*for (int iloc=0;iloc<6;iloc++) {
    cout<<Vh(0,iloc)<<endl;
}*/





//////////////


/*
for (int i=0;i<Wh.ndof;i++) {
    rhs[i] = data[i];
}
for (int i=0;i<Wh.ndof;i++) {
    rhs[Wh.ndof+i] = rhs2[i];
}*/

//defining the right hand side
//real[int] rhs1 = rhspb1(0,Wh);
//real[int] sol1(Wh.ndof);


/*
real[int] rhs2 = rhspb2(0,Wh);

//Just a test
Wh phi ;
phi[] = rhs2;
plot(phi,wait=1,value=1,cmm="phi");

//real[int] sol2(Wh.ndof);
real[int] rhs(2*Wh.ndof);
for (int i=0;i<Wh.ndof;i++) {
    rhs[i]=rhs1[i];
    rhs[Wh.ndof+i]=rhs2[i];
}


/////Compute the solution on the big space
real[int] sol(2*Wh.ndof);
sol = A^-1*rhs;

real[int] usol(Wh.ndof);
for (int i=0;i<Wh.ndof;i++) {
    usol[i]=sol[i];
}

//take U

Wh U;
U[] = usol;
real norm = sqrt(int2d(Th) (U^2));
cout<<"Norme L2 de la solution :"<<norm<<endl;*/


plot(Th,wait=1);
plot(u,wait=1,value=1,cmm="u");




//plot(U,wait=1,value=1,cmm="sol");

//nettoyer le code
//faire un commit
//courbes de cv  